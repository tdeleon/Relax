<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Relax  Reference</title>
    <link rel="stylesheet" type="text/css" href="css/jazzy.css" />
    <link rel="stylesheet" type="text/css" href="css/highlight.css" />
    <meta charset='utf-8'>
    <script src="js/jquery.min.js" defer></script>
    <script src="js/jazzy.js" defer></script>
    
  </head>
  <body>
    <a title="Relax  Reference"></a>
    <header>
      <div class="content-wrapper">
        <p><a href="index.html">Relax Docs</a></p>
        <p class="header-right"><a href="https://github.com/tdeleon/Relax"><img src="img/gh.png"/>View on GitHub</a></p>
      </div>
    </header>
    <div class="content-wrapper">
      <p id="breadcrumbs">
        <a href="index.html">Relax Reference</a>
        <img id="carat" src="img/carat.png" />
        Relax  Reference
      </p>
    </div>
    <div class="content-wrapper">
      <nav class="sidebar">
        <ul class="nav-groups">
          <li class="nav-group-name">
            <a href="Defining%20Services.html">Defining Services</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Protocols/Service.html">Service</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Making%20Requests.html">Making Requests</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Protocols/ServiceRequest.html">ServiceRequest</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/HTTPRequestMethod.html">HTTPRequestMethod</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/RequestContentType.html">RequestContentType</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/RequestError.html">RequestError</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
      <article class="main-content">
        <section>
          <section class="section">
            
            <h1 style="text-align: center;"><img src="https://user-images.githubusercontent.com/3507743/82412732-08c9c900-9a29-11ea-9eb4-0f7caea45e6e.png" height="60" style="vertical-align: middle; padding-right: 20px">Relax</h1>

<hr>

<p><img src="https://img.shields.io/github/license/tdeleon/Relax" alt="GitHub">
<a href="https://swift.org"><img src="https://img.shields.io/badge/Swift-5.2-brightgreen.svg?colorA=orange&colorB=4E4E4E" alt="Swift"></a>
<a href="https://swift.org/package-manager/"><img src="https://img.shields.io/badge/SPM-compatible-brightgreen" alt="SPM"></a>
<a href="https://swift.org"><img src="https://img.shields.io/badge/platforms-macOS%20%7C%20iOS%20%7C%20watchOS%20%7C%20tvOS%20%7C%20Linux-lightgrey" alt="Platforms"></a>
<img src="https://github.com/tdeleon/Relax/workflows/Test/badge.svg?branch=master" alt="Test"></p>

<p><em>A Protocol-Oriented Swift library for building REST client requests</em></p>
<h2 id='overview' class='heading'>Overview</h2>

<p>Relax is a client library for defining REST services and requests, built on the concept of <a href="https://developer.apple.com/videos/play/wwdc2015/408/"><em>Protocol Oriented Programming</em></a>. This means that it is largely built with protocols, allowing
for a great deal of flexibility in it&rsquo;s use.</p>
<h3 id='reference-documentation' class='heading'>Reference Documentation</h3>

<p><a href="https://tdeleon.github.io/Relax/">https://tdeleon.github.io/Relax/</a></p>
<h3 id='features' class='heading'>Features</h3>

<ul>
<li><strong>Lightweight &amp; Simple</strong>:  based on protocols, works directly on URLSession for best performance and low overhead</li>
<li><strong>Customizable</strong>: Allows for customization when desired (specify your own URLSession; manually <code>resume()</code> or <code>cancel()</code> URLSessionTasks as needed)</li>
<li><strong>Structured</strong>: Helps organize complex REST API request</li>
<li>Support for Combine (on available platforms)</li>
</ul>
<h3 id='platforms' class='heading'>Platforms</h3>

<p>Relax is available on all Swift supported platforms, including:</p>

<ul>
<li>macOS</li>
<li>iOS</li>
<li>tvOS</li>
<li>watchOS</li>
<li>Linux</li>
</ul>
<h2 id='getting-started' class='heading'>Getting Started</h2>
<h3 id='adding-to-a-project' class='heading'>Adding to a Project</h3>

<p>Relax can be added to projects using the Swift Package Manager, or added as a git submodule.</p>
<h4 id='swift-package-manager' class='heading'>Swift Package Manager</h4>

<p>In <em>Package.swift</em>:</p>

<ol>
<li><p>Add to the package dependencies array</p>
<pre class="highlight plaintext"><code>dependencies: [
    .package(url: "https://github.com/tdeleon/Relax.git", from: "1.0.0")
]
</code></pre></li>
<li><p>Add <em>Relax</em> to your target&rsquo;s dependencies array</p>
<pre class="highlight plaintext"><code>targets: [
    .target(
        name: "YourProject",
        dependencies: ["Relax"])
]
</code></pre></li>
</ol>
<h3 id='usage' class='heading'>Usage</h3>

<p>Import the Relax framework where it will be used</p>
<pre class="highlight plaintext"><code>import Relax
</code></pre>
<h2 id='concepts' class='heading'>Concepts</h2>

<p>The Relax framework comprises mainly of two protocols- <code><a href="Protocols/Service.html">Service</a></code> and <code><a href="Protocols/ServiceRequest.html">ServiceRequest</a></code>. They can be implemented as structs or classes,
whichever fits better with your use case. Most often you will want to use structs to define services and requests (due to the value semantics and immutabilty), but there is no requirement to do so. For more general information on the differences between structs and classes in Swift, see
<a href="https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html">the official Swift documentation</a>.</p>
<h3 id='service' class='heading'>Service</h3>

<p>The <code><a href="Protocols/Service.html">Service</a></code> protocol represents a REST API service that you will make requests to. Each service has a distinct base URL, and all requests
made to the service will use this base URL. Use services to logically group requests together for better organization and code reusability.</p>

<blockquote>
<p><strong>Note:</strong> For implementing dynamic base URLs (such as with different environments like Dev, Stage, Prod, etc), 
it is not necessary to define multiple services.</p>
</blockquote>

<p>This protocol only has two properties- <code><a href="Protocols/Service.html#/s:5Relax7ServiceP7baseURL10Foundation0D0Vvp">Service.baseURL</a></code> and <code><a href="Protocols/Service.html#/s:5Relax7ServiceP7sessionSo12NSURLSessionCvpZ">Service.session</a></code>. The <code>baseURL</code> property is required to be implemented, and 
provides the base URL used for all requests. The <code>session</code> property is a <code>URLSession</code> instance which requests to this service will be made with. 
This property has a default implementation of  <code>URLSession.shared</code>, but you can override this with your own. Additionally, when making 
requests, a session may be passed in to override for a per request.</p>
<h3 id='servicerequest' class='heading'>ServiceRequest</h3>

<p>The <code><a href="Protocols/ServiceRequest.html">ServiceRequest</a></code> protocol represents HTTP requests made against  a <code><a href="Protocols/Service.html">Service</a></code>.  Requests can be any of the <code><a href="Enums/HTTPRequestMethod.html">HTTPRequestMethod</a></code> types. 
The <code><a href="Protocols/ServiceRequest.html#/s:5Relax14ServiceRequestP10httpMethodAA011HTTPRequestE0Ovp">ServiceRequest.httpMethod</a></code> is the only property that you must provide a value for- all others provide a default implementation.</p>

<p>Requests can be customized with:</p>

<ul>
<li>Path components - see <code><a href="Protocols/ServiceRequest.html#/s:5Relax14ServiceRequestP14pathComponentsSaySSGvp">ServiceRequest.pathComponents</a></code>.</li>
<li>Query parameters - see <code><a href="Protocols/ServiceRequest.html#/s:5Relax14ServiceRequestP15queryParametersSay10Foundation12URLQueryItemVGvp">ServiceRequest.queryParameters</a></code>.</li>
<li>Headers - see <code><a href="Protocols/ServiceRequest.html#/s:5Relax14ServiceRequestP7headersSDyS2SGvp">ServiceRequest.headers</a></code>.</li>
<li>Content type (this value will be added to the <code>URLRequest.allHTTPHeaders</code> field) - see <code><a href="Protocols/ServiceRequest.html#/s:5Relax14ServiceRequestP11contentTypeAA0c7ContentE0VSgvp">ServiceRequest.contentType</a></code>.</li>
<li>Request body - see <code><a href="Protocols/ServiceRequest.html#/s:5Relax14ServiceRequestP4body10Foundation4DataVSgvp">ServiceRequest.body</a></code>.</li>
</ul>

<p>To make a request, simply call the <code>request()</code> method on the <code><a href="Protocols/Service.html">Service</a></code>. There are two versions of this method, one using a completion closure,
and another which returns a Combine publisher (available on platforms where Combine is supported). For more details, see <code><a href="Protocols/Service.html#/s:5Relax7ServicePAAE7request_7session14autoResumeTask10completionSo016NSURLSessionDataG0CSgqd___So0I0CSbys6ResultOy10Foundation10URLRequestVAD_So17NSHTTPURLResponseC8responseAO0J0VSg4datatAA12RequestErrorOGctAA0bQ0Rd__lF">Service.request(_:session:autoResumeTask:completion:)</a></code> or <code><a href="Protocols/Service.html#/s:5Relax7ServicePAAE7request_7session7Combine12AnyPublisherVy10Foundation10URLRequestVAD_So17NSHTTPURLResponseC8responseAI4DataV4datatAA12RequestErrorOGqd___So12NSURLSessionCtAA0bN0Rd__lF">Service.request(_:session:)</a></code>. </p>
<h2 id='examples' class='heading'>Examples</h2>
<h3 id='basic' class='heading'>Basic</h3>

<p>As a minimum, a request only needs the <code><a href="Enums/HTTPRequestMethod.html">HTTPRequestMethod</a></code> defined. For example:</p>
<pre class="highlight plaintext"><code>struct ExampleService: Service {
   let baseURL: URL = URL(string: "https://example.com/api/")!

   struct Get: ServiceRequest {
      let httpMethod: HTTPRequestMethod = .get
   }
}

ExampleService().request(ExampleService.Get()) { response in
   ...
}
</code></pre>
<h3 id='dynamic-base-urls' class='heading'>Dynamic Base URLs</h3>
<pre class="highlight plaintext"><code>struct ExampleService: Service {
    var baseURL: URL

    struct Get: ServiceRequest {
       let httpMethod: HTTPRequestMethod = .get
    } 
}

let devURL = URL(string: "https://dev.example.com/")!

ExampleService(baseURL: devURL).request(MyRequest()) { response in
    ...
}
</code></pre>
<h3 id='paths' class='heading'>Paths</h3>
<pre class="highlight plaintext"><code>struct ExampleService: Service {
    let baseURL: URL = URL(string: "https://example.com/api/")!

    // Get request at /products
    struct GetProducts: ServiceRequest {
       let httpMethod: HTTPRequestMethod = .get
       var productID: String
       var queryParameters: [String] {
          return ["products", productID]
       }
    }
}

// Request product with ID "123" - URL: https://example.com/api/products/123
ExampleService().request(ExampleService.GetProducts(productID: "123")) { response in
    ...
}
</code></pre>
<h3 id='grouping-requests' class='heading'>Grouping Requests</h3>
<pre class="highlight plaintext"><code>struct ExampleService: Service {
    let baseURL: URL = URL(string: "https://example.com/api/")!

    struct Customer {
        static let basePath = "customer"

        // Get customer by customer ID
        struct Get: ServiceRequest {
            let httpMethod: HTTPRequestMethod = .get

            var customerID: String
            var pathComponents: [String] {
                return [Customer.basePath, customerID]
            }
        }

        // Add new customer with customer ID, name
        struct Add: ServiceRequest {
            let httpMethod: HTTPRequestMethod = .post
            let pathComponents: [String] = [Customer.basePath]

            var customerID: String
            var name: String

            var body: Data? {
                // Create JSON from arguments
                let dictionary = ["id": customerID, "name": name]
                return try? JSONSerialization.data(withJSONObject: dictionary, options: [])
            }
        }
    }
}

// Add customer with name "First Last" and ID "123"
ExampleService().request(ExampleService.Customer.Add(customerID: "123", name: "First Last")) { response in
    ...
}

// Request customer with ID "123"
ExampleService().request(ExampleService.Customer.Get(customerID: "123")) { response in
    ...
}
</code></pre>
<h3 id='adding-convenience-methods' class='heading'>Adding Convenience Methods</h3>
<pre class="highlight plaintext"><code>struct ExampleService: Service {
    let baseURL: URL = URL(string: "https://example.com/api/")!

    struct Customer {
        static let basePath = "customer"

        // Convenience method to add customer
        static func add(id: String, name: String) {
            let request = ExampleService.Customer.Add(customerID: id, name: name)
            ExampleService().request(request) { response in
                // handle response here
                ...
            }
        }

        // Add new customer with customer ID, name
        struct Add: ServiceRequest {
            let httpMethod: HTTPRequestMethod = .post
            let pathComponents: [String] = [Customer.basePath]

            var customerID: String
            var name: String

            var body: Data? {
                // Create JSON from arguments
                let dictionary = ["id": customerID, "name": name]
                return try? JSONSerialization.data(withJSONObject: dictionary, options: [])
            }
        }
    }
}

// Add customer with name "First Last" and ID "123"
ExampleService.Customer.add(id: "123, name: "First Last")
</code></pre>
<h3 id='using-combine' class='heading'>Using Combine</h3>
<h4 id='service-definition' class='heading'>Service Definition</h4>
<pre class="highlight plaintext"><code>struct ExampleService: Service {
    let baseURL: URL = URL(string: "https://example.com/api/")!

    struct Customer {
        static let basePath = "customer"

        struct Response: Codable {
            let name: String
            let customerID: String
        }

        // Get customer by customer ID
        struct Get: ServiceRequest {
            let httpMethod: HTTPRequestMethod = .get

            var customerID: String
            var pathComponents: [String] {
                return [Customer.basePath, customerID]
            }
        }

        // Add new customer with customer ID, name
        struct Add: ServiceRequest {
            let httpMethod: HTTPRequestMethod = .post
            let pathComponents: [String] = [Customer.basePath]

            var customerID: String
            var name: String

            var body: Data? {
                // Create JSON from arguments
                let dictionary = ["id": customerID, "name": name]
                return try? JSONSerialization.data(withJSONObject: dictionary, options: [])
            }
        }
    }
}
</code></pre>
<h4 id='making-a-request' class='heading'>Making a Request</h4>
<pre class="highlight plaintext"><code>cancellable = ExampleService().request(ExampleService.Customer.Get())
    .map { $0.data }
    .decode(type: ExampleService.Customer.Response.self, decoder: JSONDecoder())
    .sink(receiveCompletion: { completion in
        switch completion {
        case .finished:
            break
        case .failure(let error):
            debugPrint("Received error: \(error)")
        }

    }, receiveValue: { product in
        debugPrint("Received product: \(product)")
    })
</code></pre>

          </section>
        </section>
        <section id="footer">
          <p>© 2020 Thomas De Leon, all rights reserved.</p>
          <p>Generated by <a class="link" href="https://github.com/realm/jazzy" target="_blank" rel="external">jazzy ♪♫ v0.13.3</a>, a <a class="link" href="https://realm.io" target="_blank" rel="external">Realm</a> project.</p>
        </section>
      </article>
    </div>
  </body>
</div>
</html>
